PYTHON-SPECIFIC RULES

GENERAL BEST PRACTICES
All code MUST be fully type-hinted using the typing module.

Code MUST adhere to PEP 8 style guidelines. Use ruff for formatting.

All public functions and classes MUST have Google-style docstrings.

Use f-strings for string formatting.

Avoid mutable default arguments in function definitions. Use None and initialize inside the function.

PROJECT STRUCTURE & DEPENDENCIES
The project MUST use a src layout.

All dependencies MUST be managed in pyproject.toml using Poetry. Do not use requirements.txt.

A Makefile MUST be provided with standard targets: install, build, test, lint, run.

MAKEFILE GENERATION RULES

You MUST generate a Makefile for every project. The content of the run command in the Makefile depends on the project_type specified by the user.

If project_type is "fastapi_web_service":
The run command MUST use uvicorn to start the server.
Example: poetry run uvicorn src.main:app --reload

For all other project_type values (e.g., "cli", "data_script"):
The run command MUST execute the main script as a module using Python's -m flag.
Example: poetry run python -m src.main

README.md GENERATION
A README.md file MUST be generated.

It MUST contain the following sections, using the content from the spec where appropriate:

Project Title: # {{ spec.project.name }}

Project Description: {{ spec.project.description }}

Getting Started: Instructions for make install and make run.

Development: Instructions for make test and make lint.

Project Structure: A brief overview of the directory layout.

PYPROJECT.TOML BEST PRACTICES
The [tool.poetry] section MUST include the line packages = [{include = "src"}] to correctly identify the source directory.

The [tool.poetry.dependencies] section MUST include a modern Python version, for example: python = "^3.9".

The [tool.poetry.group.dev.dependencies] section MUST be used for development dependencies.

Use these specific, known-good versions for core development tools:

pytest = "^8.2.0"

ruff = "^0.4.0"

httpx = "^0.27.0" # For testing FastAPI

WEB APIS (FastAPI)
If the project is a web service, it MUST use FastAPI and Uvicorn.

The [tool.poetry.dependencies] section MUST include fastapi = "^0.110.0" and uvicorn = {extras = ["standard"], version = "^0.29.0"}.

A root endpoint at / MUST be included. It should return a simple JSON response like {"status": "ok"}.

Use Pydantic models for all request and response bodies to ensure type safety and automatic validation.

Leverage FastAPI's Dependency Injection system for shared resources like database connections.

All path operations (endpoints) MUST be async def.

The run target in the Makefile MUST use uvicorn to start the server (e.g., poetry run uvicorn src.main:app --reload).

DATA SCIENCE (Pandas / Polars)
Prefer Polars for new projects due to its performance, but Pandas is acceptable.

If using Polars, you MUST also include pyarrow in the dependencies, as it's required for many operations (e.g., polars = "^0.20.0" and pyarrow = "^15.0.0").

Emphasize method chaining and expressive, readable pipelines.

AVOID iterating over rows (for index, row in df.iterrows()). Use vectorized operations or apply with care.

Clearly separate data loading, cleaning, transformation, and analysis steps into distinct functions.

MACHINE LEARNING (Scikit-learn / PyTorch)
Structure the code into logical steps: data loading, preprocessing, feature engineering, model training, evaluation, and prediction.

Use Scikit-learn's Pipeline to chain preprocessing and model steps.

Save trained models using joblib (for Scikit-learn) or torch.save (for PyTorch).

Include a script or function to load the model and make predictions on new data.

VISUALIZATION (Matplotlib / Plotly)
If the project generates plots, it MUST include matplotlib as a dependency (e.g., matplotlib = "^3.8.0").

All plots MUST have clear titles, axis labels, and legends.

Do not just display plots (plt.show()). Instead, save them to a file (e.g., .png) in a designated outputs/ or plots/ directory.

TESTING (pytest)
Tests MUST be placed in a top-level tests/ directory.

Use pytest fixtures for setup and teardown (e.g., creating temporary data files).

Write small, focused unit tests for individual functions.

For FastAPI, use httpx and TestClient for integration tests.

ERROR HANDLING
Define custom exception classes for application-specific errors. Do not raise generic Exception.

Use try...except blocks to handle expected errors gracefully (e.g., FileNotFoundError, network errors).

